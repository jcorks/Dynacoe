<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- For Mobile Devices -->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.8.8"/>
        <meta keywords="OpenGL, Dynacoe, Coebeef, development, multimedia, C++, toolkit, game programming, library, documentation"/>
        <meta author="Johnathan Corkery (jcorkery - at - umich.edu)"/>
        <!--<script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>-->
        <script type="text/javascript" src="jquery-2.1.1.min.js"></script>
        <title>Dynacoe: Using Shaders: GLSL</title>
        <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
        <script type="text/javascript" src="dynsections.js"></script>
        <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <!--<link href='https://fonts.googleapis.com/css?family=Roboto+Slab' rel='stylesheet' type='text/css'>-->
        <link rel="stylesheet" href="bootstrap3.3.1.css">
        <script src="bootstrap3.3.1.min.js"></script>
        <script type="text/javascript" src="doxy-boot.js"></script> 
        <link href="dynacoe.css" rel="stylesheet" type="text/css"/>
    </head>
    <body>
        <!-- navbar is extraneous for Dynacoe, since the entire site is for documentation. Doxygen 
             provides enough navigation -->
        <nav class="navbar navbar-default" role="navigation">
            <div class="container header-top">
                <!--<div class="navbar-header">-->
                    <!--<a class="navbar-brand">-->
                        <img class = "header-img" src="dynacoe-logo-half.png"/>
                <!--</div>-->
            </div>
        </nav>
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel " style="padding-bottom: 15px;">
                            <div style="margin-bottom: 15px;">
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Guides</span></a></li>
      <li><a href="downloads.html"><span>Downloads</span></a></li>
      <li><a href="annotated.html"><span>Documentation</span></a></li>
      <li><a href="contact.html"><span>Contact</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Modules</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Using Shaders: GLSL </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Using the included OpenGL renderer, it is possible to include and run your own shader programs in the GLSL language with your project. Depending on what version of OpenGL you have running, Dynacoe will support</p><ul>
<li>GLSL 1.2</li>
<li>GLSL 1.3</li>
<li>GLSL 1.4</li>
</ul>
<p>For maximum portability, it's probably best to stick to GLSL 1.2 (yeah, I know it's old.. but it should be good enough for most things!)</p>
<p>Besides, along with pure language support, Dynacoe provides interfacing and utility functions to help write your programs.</p>
<h2>Uniforms </h2>
<p>These uniforms provide a mechanism to interface with static data provided when issuing a render. It allows you to access material data and calculated parameters from the camera.</p>
<p>```{.c}</p>
<p>//_________ Camera Matrices _________//</p>
<p>// 4x4 matrix containing view transform from the current Camera. mat4 Dynacoe_ViewTransform;</p>
<p>// 4x4 matrix containing the projection matrix from the current Camera. mat4 Dynacoe_ProjectionTransform;</p>
<p>// 4x4 matrix containing object-local transform from the current // AspectMesh / StaticState being drawn. mat4 Dynacoe_ModelTransform;</p>
<p>// Equivalent to inverse(transpose(Dynacoe_ViewTransform)) to // correctly transform normals. (Rarely useful, you will usually // want Dynacoe_ModelNormalTransform) mat4 Dynacoe_ViewNormalTransform;</p>
<p>// Equivalent to inverse(transpose(Dynacoe_ModelTransform)) to // correctly transform normals. mat4 Dynacoe_ModelNormalTransform;</p>
<p>//__________ Material data ___________//</p>
<p>// Ambient light color from the material vec3 Dynacoe_MaterialAmbient;</p>
<p>// Diffuse light RGB of the attached material vec3 Dynacoe_MaterialDiffuse;</p>
<p>// Intensity of the diffuse color of the attached material float Dynacoe_MaterialDiffuseAmount;</p>
<p>// Specular light RGB of the attached material vec3 Dynacoe_MaterialSpecular;</p>
<p>// Intensity of the specular color of the attached material float Dynacoe_MaterialSpecularAmount;</p>
<p>// The shininess amount from the attached material float Dynacoe_MaterialShininess;</p>
<p>// The auxiliary data set by the user in the material vec4[8] Dynacoe_MaterialData;</p>
<p>```</p>
<h2>Inputs </h2>
<p>Usually in GLSL, you need to specify the inputs into the Vertex shader using the <code>in</code> or <code>varying</code> qualifier. Dynacoe handles the linking of the data under-the-hood, so that part is done for you. As such, every vertex shader will have the same inputs:</p>
<p>```{.c} // The position of the input vertex. vec3 Dynacoe_Position;</p>
<p>// The normal of the input vertex. vec3 Dynacoe_Normal;</p>
<p>// The texture coordinates of the input vertex. vec2 Dynacoe_UV;</p>
<p>// User-specified data specified through the Mesh. (See <a class="el" href="classDynacoe_1_1Mesh.html" title="3D object defined by triangle primitives. ">Dynacoe::Mesh</a>) vec4 Dynacoe_Input; ```</p>
<p>These represent the vertex position, normal vector, and texture coordinates respectively. You have explicit control over these attriutes via AspectMesh, Mesh, and MeshObject, since these are the only kinds of objects that are drawn with shaders.</p>
<h2>Sampling </h2>
<p>Dynacoe does not provide any means to connect to <code>sampler</code>s. Instead, Dynacoe allows you to sample all the textures you've specified in the meshing interface. Each time you AddTexture() to an AspectMesh, a unique index refers to that texture. Starting at 0, each new texture gets the subsequent index within the AspectMesh. ```{.c}</p>
<p>// Samples the given texture index at the given texture coordinates. // If textureIndex does not refer to a valid texture slot, the resulting // color is undefined. vec4 Dynacoe_SampleColor(in int textureIndex, in vec2 uv);</p>
<p>// Samples shininess information from the given texture. float Dynacoe_SampleShininess(in int textureIndex, in vec2 uv);</p>
<p>// Returns whether the texture index has a texture binding associated with it. bool Dynacoe_SlotHasTexture(in int textureIndex);</p>
<p>// Returns the normal vector from the given texture. vec3 Dynacoe_SampleNormal(in int textureIndex, in vec2 uv);</p>
<p>```</p>
<p>Because you specify the index as a generic index, the actual number of reachable textures quite high. The minimum is 64, but if running opengl 3.0 or higher, its somewhere on the order of 1024 simulateous texture bindings. This makes it possible to render complex scenes in very few draws.</p>
<p>Along with regular texture sampling, you can also sample from previously drawn scenes via the last drawn visual in the Camera passed to AspectMesh::SetFramebufferSource(). You sample it much like a texture.</p>
<p>```{.c}</p>
<p>// Returns whether theres an attached framebuffer texture to sample from // If there isn't one, trying to sample the framebuffer // results in undefined texel colors. bool Dynacoe_CanSampleFramebuffer();</p>
<p>// Samples the attached camera's visual as a texture. vec4 Dynacoe_SampleFramebuffer(in vec2 uv);</p>
<p>```</p>
<h2>Lighting </h2>
<p>Dynacoe also provides basic lighting capability that integrates with AspectLights. Keep in mind that the positional inputs need to be in the same world space. This can be tricky to wrap your head around, but check out the Shader sample to see an example of how you can do it. ```{.c}</p>
<p>// Standard function that calulates the color of a fragment of a surface // given the fragment's world position, normal, // view direction, and material attributes. This applies all // enabled AspectLights and considers their respective types vec3 Dynacoe_CalculateLightFragment( in vec3 position, in vec3 normal, in vec3 viewDir, in float diffuseAmount, in vec3 diffuseColor, in float specularAmount, in vec3 specularColor );</p>
<p>// Calculates the light from a single point-style light. // Point lights obey the inserse-square law for brightness vs. distance, // emulating the behavior of a localized light source in all directions. // Inputs are the same as CalculateLightFragment() but // adds a parameter for the light's position vec3 Dynacoe_PointLight( in vec3 position, in vec3 normal, in vec3 lightPos, in vec3 viewDir, in float diffuseAmount, in vec3 diffuseColor, in float specularAmount, in vec3 specularColor );</p>
<p>// Calculates the light from a single directional-style light. // Directional lights cast light in a direction with uniform brightness regardless of // surface position. Directional lights emulate very bright and distanced lights, // i.e. the sky light, or ambient lighting. Inputs follow from Dynacoe_PointLight, // but the lighting position is now a lighting direction. vec3 Dynacoe_DirectionalLight( in vec3 position, in vec3 normal, in vec3 lightDir, in vec3 viewDir, in float diffuseAmount, in vec3 diffuseColor, in float specularAmount, in vec3 specularColor );</p>
<p>``` </p>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div> 
</div>
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
